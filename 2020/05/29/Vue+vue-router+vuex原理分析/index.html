<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Vue," />










<meta name="description" content="Vue源码中有很多零碎知识点值得学习，本篇博文记录学习Vue中常见API的实现原理。">
<meta name="keywords" content="Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue+vue-router+vuex原理分析">
<meta property="og:url" content="https://blog.91sam.com/2020/05/29/Vue+vue-router+vuex原理分析/index.html">
<meta property="og:site_name" content="三木">
<meta property="og:description" content="Vue源码中有很多零碎知识点值得学习，本篇博文记录学习Vue中常见API的实现原理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-07-04T03:15:15.463Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue+vue-router+vuex原理分析">
<meta name="twitter:description" content="Vue源码中有很多零碎知识点值得学习，本篇博文记录学习Vue中常见API的实现原理。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.91sam.com/2020/05/29/Vue+vue-router+vuex原理分析/"/>





  <title>Vue+vue-router+vuex原理分析 | 三木</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三木</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">你是谁就遇到谁</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.91sam.com/blog/2020/05/29/Vue+vue-router+vuex原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三木">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三木">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Vue+vue-router+vuex原理分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-29T23:11:10+08:00">
                2020-05-29
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/blog/2020/05/29/Vue+vue-router+vuex原理分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/blog/2020/05/29/Vue+vue-router+vuex原理分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Vue源码中有很多零碎知识点值得学习，本篇博文记录学习Vue中常见API的实现原理。<br><a id="more"></a></p>
<blockquote>
<p>new Vue初始化流程</p>
</blockquote>
<ul>
<li>介绍<br>Vue初始化是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: &apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>传入的参数是一个object,包含了绑定的根节点<code>#app</code>和初始化数据<code>data</code>。<br>查看Vue源码，Vue构造函数执行初始化方法<code>_init(options)</code>，<code>_init</code>依次执行了以下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions() // 扩展vue $options方法，该方法可以merge对象属性，扩展了vue属性</span><br><span class="line">initProxy(vm);  //为vue _renderProxy属性设置proxy代理。这层代理会在模板渲染时对一些非法或者没有定义的变量进行筛选判断</span><br><span class="line">vm._self = vm;</span><br><span class="line">initLifecycle(vm);  //添加初始化生命周期属性</span><br><span class="line">initEvents(vm); //绑定组件上的事件, 涉及到$on，$once, $off, $emit</span><br><span class="line">initRender(vm); //最主要的方法是defineReactive$$1，通过Object.defineProperty + 观察者模式，实现数据拦截</span><br><span class="line">callHook(vm, &apos;beforeCreate&apos;);   // 调用生命周期钩子 beforeCreate</span><br><span class="line">initInjections(vm); // 解析inject属性</span><br><span class="line">initState(vm);  //初始化props,methods, data,computed,watch属性</span><br><span class="line">initProvide(vm); // 解析provide属性</span><br><span class="line">callHook(vm, &apos;created&apos;);    //  调用生命周期钩子 created</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el);  // 生成template -&gt; 生成render函数 -&gt; 调用beforeMount -&gt; 生成VNode -&gt; vm._update生成真实DOM -&gt; mounted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>nextTick</p>
</blockquote>
<ul>
<li><p>介绍<br>nextTick用于下一次DOM更新执行的方法，当赋值变量之后，DOM节点并没有及时更新，所以此时获取节点内容并不是最新的，因此需要使用nextTick在DOM节点变化之后，获取最新的DOM。</p>
</li>
<li><p>原理<br>nextTick是采用异步控制+优雅降级的方式，以v2.6版本为例，降级策略为根据浏览器兼容性依次判断是否支持Promise -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout。<br>其中，Promise和MutationObserver属于微任务队列，setImmediate和setTimeout属于宏任务队列，微任务比宏任务优先执行。<br>nextTick将回调方法收集到callbacks数组中，在异步任务执行时，将callbacks中的函数依次执行。<br>例如在使用MutationObserver时，源码中创建了一个node节点，MutationObserver监听此节点内容的变化。当需要执行nextTick的回调函数时，手动触发node节点内容的变化，推动MutationObserver触发监听，执行callbacks中的方法。</p>
</li>
</ul>
<blockquote>
<p>双向绑定</p>
</blockquote>
<ul>
<li><p>介绍<br>Vue最基本的功能便是双向绑定，与jQuery相比，极大地方便了DOM操作，可以说是革了jQuery的命。使开发者可以专注于数据操作，数据推动DOM变化。</p>
</li>
<li><p>原理<br>Vue初始化绑定data数据是在initState中的initData</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function initState (vm) &#123;</span><br><span class="line">    vm._watchers = [];</span><br><span class="line">    var opts = vm.$options;</span><br><span class="line">    if (opts.props) &#123; initProps(vm, opts.props); &#125;</span><br><span class="line">    if (opts.methods) &#123; initMethods(vm, opts.methods); &#125;</span><br><span class="line">    if (opts.data) &#123;</span><br><span class="line">      initData(vm);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      observe(vm._data = &#123;&#125;, true /* asRootData */);</span><br><span class="line">    &#125;</span><br><span class="line">    if (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">      initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>initData</code>中做了:</p>
<ol>
<li>判断数据类型是否合规；</li>
<li>判断是否有重名的key,比如props中和data中不能有相同的属性；</li>
<li><code>proxy(vm, &quot;_data&quot;, key);</code>代理data中的对象到this下。实现可以app.name可以调用app._data.name</li>
<li><code>observe(data, true /* asRootData */);</code>绑定数据</li>
</ol>
<p>再看observe:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function observe (value, asRootData) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">      ob = value.__ob__;</span><br><span class="line">    &#125; else if (</span><br><span class="line">      shouldObserve &amp;&amp;</span><br><span class="line">      !isServerRendering() &amp;&amp;</span><br><span class="line">      (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">      Object.isExtensible(value) &amp;&amp;</span><br><span class="line">      !value._isVue</span><br><span class="line">    ) &#123;</span><br><span class="line">      ob = new Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是先判断是否有<code>__ob__</code>,如果没有，就把<code>__ob__</code>设为new Observer实例。</p>
<p>再看Observer:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var Observer = function Observer (value) &#123;</span><br><span class="line">  this.value = value;</span><br><span class="line">  this.dep = new Dep();   </span><br><span class="line">  this.vmCount = 0;</span><br><span class="line">  def(value, &apos;__ob__&apos;, this); //将Observer绑定到`__ob__`下</span><br><span class="line">  if (Array.isArray(value)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    this.observeArray(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>walk</code>和<code>observeArray</code>是针对对象和数组进行数据绑定，数组的话，就循环针对每一个属性进行绑定。<br>walk:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observer.prototype.walk = function walk (obj) &#123;</span><br><span class="line">    var keys = Object.keys(obj);</span><br><span class="line">    for (var i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive$$1(obj, keys[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>walk就是针对对象中的每一个属性进行循环绑定。<br><code>defineReactive$$1</code>这里就是使用<code>Object.defineProperty</code>的<code>set</code>,<code>get</code>进行数据绑定，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">get: function reactiveGetter () &#123;</span><br><span class="line">    //这里主要是判断用户是否自定义了getter，如有,就是用自定义getter</span><br><span class="line">    var value = getter ? getter.call(obj) : val;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line">          dependArray(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function reactiveSetter (newVal) &#123;</span><br><span class="line">  </span><br><span class="line">    var value = getter ? getter.call(obj) : val;</span><br><span class="line">    /* eslint-disable no-self-compare */</span><br><span class="line">    if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    /* eslint-enable no-self-compare */</span><br><span class="line">    if (customSetter) &#123;</span><br><span class="line">      customSetter();</span><br><span class="line">    &#125;</span><br><span class="line">    // #7981: for accessor properties without setter</span><br><span class="line">    if (getter &amp;&amp; !setter) &#123; return &#125;</span><br><span class="line">    if (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">    //  新修改的属性，进行数据绑定</span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>dep用于依赖管理，收集Watcher。它会用subs收集Watcher，当执行setter时，就将subs中的Watcher依次循环，执行每一个Watcher的notify。</p>
<p>总的数据管理流程就是：Observer -&gt; dep -&gt; watcher</p>
<blockquote>
<p>Vue异步更新过程</p>
</blockquote>
<ul>
<li><p>介绍<br>当js中的变量发生变化时，DOM上绑定变量的节点内容并没有立刻发生变化，而是通过nextTick将tick之间发生的内容变化，一次性更新在DOM上的。</p>
</li>
<li><p>原理<br>以如下代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p @click=&quot;handleClick&quot;&gt;&#123;&#123; test &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      data:&#123;</span><br><span class="line">          test: &apos;111&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods:&#123;</span><br><span class="line">          handleClick()&#123;</span><br><span class="line">              this.test = this.test * 1 + 1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>当点击P标签时，会触发<code>handleClick</code>,首先要获取<code>this.test</code>, Vue是通过<code>proxy</code>将<code>this._data</code>下的变量代理到this下的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function proxy (target, sourceKey, key) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = function proxyGetter () &#123;</span><br><span class="line">      return this[sourceKey][key]</span><br><span class="line">    &#125;;</span><br><span class="line">    sharedPropertyDefinition.set = function proxySetter (val) &#123;</span><br><span class="line">      this[sourceKey][key] = val;</span><br><span class="line">    &#125;;</span><br><span class="line">    Object.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>proxy的get会调用<code>Object.defineProperty</code>的get。<br>当给test赋新值时，又通过proxy的set调用<code>Object.defineProperty</code>的set。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">set: function reactiveSetter (newVal) &#123;</span><br><span class="line">        </span><br><span class="line">        var value = getter ? getter.call(obj) : val;</span><br><span class="line">        //如果新旧值相同，就不处理</span><br><span class="line">        if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        //如果有自定义的setter, 就去执行自定义的setter</span><br><span class="line">        if (customSetter) &#123;</span><br><span class="line">          customSetter();</span><br><span class="line">        &#125;</span><br><span class="line">        // #7981: for accessor properties without setter</span><br><span class="line">        if (getter &amp;&amp; !setter) &#123; return &#125;</span><br><span class="line">        if (setter) &#123;</span><br><span class="line">          setter.call(obj, newVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">        //这里如果新的值是对象的话，就把对象中的每一个key重新绑定响应</span><br><span class="line">        childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">        // 通知dep中的观察者去更新</span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dep.prototype.notify = function notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    var subs = this.subs.slice();</span><br><span class="line">    if (!config.async) &#123;</span><br><span class="line">      // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line">      // we need to sort them now to make sure they fire in correct</span><br><span class="line">      // order</span><br><span class="line">      subs.sort(function (a, b) &#123; return a.id - b.id; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>dep中绑定的Watcher，都在subs中。通知每一个Watcher去执行它们的update。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = function update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true;</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>update并不是立即去执行更新，而是通过queueWatcher方法把需要更新的事件放进队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function queueWatcher (watcher) &#123;</span><br><span class="line">  var id = watcher.id;</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true;</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      var i = queue.length - 1;</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher);</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true;</span><br><span class="line"></span><br><span class="line">      if (!config.async) &#123;</span><br><span class="line">        flushSchedulerQueue();</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>放进队列之后，就通过nextTick去执行队列里的事件。nextTick前面已经介绍过了，nextTick传了一个回调<code>flushSchedulerQueue</code>，Watcher的更新操作是在这个方法中进行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">  flushing = true;</span><br><span class="line">  var watcher, id;</span><br><span class="line"></span><br><span class="line">  // Sort queue before flush.</span><br><span class="line">  // This ensures that:</span><br><span class="line">  // 1. Components are updated from parent to child. (because parent is always</span><br><span class="line">  //    created before the child)</span><br><span class="line">  // 2. A component&apos;s user watchers are run before its render watcher (because</span><br><span class="line">  //    user watchers are created before the render watcher)</span><br><span class="line">  // 3. If a component is destroyed during a parent component&apos;s watcher run,</span><br><span class="line">  //    its watchers can be skipped.</span><br><span class="line">  /*</span><br><span class="line">  给queue排序，这样做可以保证：</span><br><span class="line">  1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</span><br><span class="line">  2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建</span><br><span class="line">  3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。</span><br><span class="line">*/</span><br><span class="line">  queue.sort(function (a, b) &#123; return a.id - b.id; &#125;);</span><br><span class="line"></span><br><span class="line">  // do not cache length because more watchers might be pushed</span><br><span class="line">  // as we run existing watchers</span><br><span class="line">  for (index = 0; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line">    if (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = null;</span><br><span class="line">    watcher.run();    //执行Watcher</span><br><span class="line">    // in dev build, check and stop circular updates.</span><br><span class="line">    if (has[id] != null) &#123;</span><br><span class="line">      circular[id] = (circular[id] || 0) + 1;</span><br><span class="line">      //如果超出最大更新次数，就给个提示。</span><br><span class="line">      if (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You may have an infinite update loop &apos; + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? (&quot;in watcher with expression \&quot;&quot; + (watcher.expression) + &quot;\&quot;&quot;)</span><br><span class="line">              : &quot;in a component render function.&quot;</span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        );</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // keep copies of post queues before resetting state</span><br><span class="line">  var activatedQueue = activatedChildren.slice();</span><br><span class="line">  var updatedQueue = queue.slice();</span><br><span class="line"></span><br><span class="line">  //重置队列状态</span><br><span class="line">  resetSchedulerState();</span><br><span class="line"></span><br><span class="line"> //调用生命周期钩子</span><br><span class="line">  callActivatedHooks(activatedQueue);</span><br><span class="line">  callUpdatedHooks(updatedQueue);</span><br><span class="line"></span><br><span class="line">  // devtool hook</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(&apos;flush&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一次tick过程就结束了，总的过程是：setter -&gt; dep.notify -&gt; Watcher.update -&gt; nextTick -&gt; Watcher.run</p>
<blockquote>
<p>patch和diff</p>
</blockquote>
<ul>
<li><p>介绍<br>Vue在更新DOM时，并不会全部更新DOM，而是把需要更新的节点进行更新，那么他是怎么计算哪些节点需要更新呢，这就要讲到diff算法了。diff算法是一种通过同层的树节点进行比较的高效算法，复杂度只有 O(n)</p>
</li>
<li><p>分析<br>Vue更新操作是在nextTick后执行的<code>flushCallbacks</code>，依次去执行监听者Watcher中的run方法，然后执行<code>vm._update(vm._render(), hydrating)</code>, 参数<code>vm._render()</code>就是需要更新的Vnode。_update中有一句<code>vm.$el = vm.__patch__(prevVnode, vnode);</code>，这里就是执行patch方法了。</p>
</li>
</ul>
<p><code>patch</code>中主要是判断新旧节点的差异：<br>1.如果vnode不存在，但是oldVnode存在，说明是需要销毁旧节点。<br>2.如果vnode存在，但是oldVnode不存在，说明是需要创建新节点。<br>3.当vnode和oldVnode都存在，那就要对节点进行进一步的比较<code>patchVnode</code>。</p>
<p><code>patchVnode</code>主要是对节点本身以及节点属性进行比较，对于他们的子节点的比较，就是<code>updateChildren</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">      var oldStartIdx = 0;  //旧节点开始索引</span><br><span class="line">      var newStartIdx = 0;  //新节点开始索引</span><br><span class="line">      var oldEndIdx = oldCh.length - 1; //旧节点结束索引</span><br><span class="line">      var oldStartVnode = oldCh[0]; //旧节点开始节点</span><br><span class="line">      var oldEndVnode = oldCh[oldEndIdx];   //旧节点结束节点</span><br><span class="line">      var newEndIdx = newCh.length - 1; //新节点结束索引</span><br><span class="line">      var newStartVnode = newCh[0]; //新节点开始节点</span><br><span class="line">      var newEndVnode = newCh[newEndIdx];   //新节点结束节点</span><br><span class="line">      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line"></span><br><span class="line">      // removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">      // to ensure removed elements stay in correct relative positions</span><br><span class="line">      // during leaving transitions</span><br><span class="line">      var canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        checkDuplicateKeys(newCh);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left</span><br><span class="line">        &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">          oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">        //如果旧开始节点和新开始节点相同，就递归比较他们两个节点，同时索引往中间递增，递增之后，旧开始节点和新开始节点也发生了变化，变成了原节点的相邻节点</span><br><span class="line">          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">          oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">          newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">         //如果旧结束节点和新结束节点相同，就递归比较他们两个节点，同时索引往中间递减</span><br><span class="line">          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">          oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">          newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; </span><br><span class="line">        //如果旧开始节点和新结束节点相同，就递归比较他们两个节点。同时，因为旧开始节点和新结束节点相同，所以把旧开始节点放到旧结束节点的后面。并且变化索引和赋值开始结束节点，继续循环。</span><br><span class="line">          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">          oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">          newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; </span><br><span class="line">        //如果旧结束节点和新开始节点相同，就比较他们两个节点。同时，把旧结束节点放到旧开始节点前面。并且变化索引，修改开始结束节点</span><br><span class="line">          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">          oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">          newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //如果都不满足以上四种情形，那说明没有相同的节点可以复用</span><br><span class="line">          if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125;</span><br><span class="line">          </span><br><span class="line">          idxInOld = isDef(newStartVnode.key)</span><br><span class="line">            ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            // 把旧节点用map映射的方法，查找是否有新节点与旧节点相同，如果没有找到相同的，就新建。</span><br><span class="line">          if (isUndef(idxInOld)) &#123; // New element</span><br><span class="line">            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">          //如果新老节点相同，就比较他们两个节点，并把新节点放到旧开始节点前边</span><br><span class="line">            vnodeToMove = oldCh[idxInOld];</span><br><span class="line">            if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">              oldCh[idxInOld] = undefined;</span><br><span class="line">              canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              //如果不是相同节点，就新建</span><br><span class="line">              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //如果旧节点列表先循环结束，那么说明新节点列表数量是多于旧节点列表，新开始索引和新结束索引之间的节点就判定为是新增节点，则创建。</span><br><span class="line">      if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">      &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">      //如果新节点列表先循环结束，那么说明旧节点列表数量是多于新节点列表，旧开始索引和旧结束索引之间的节点就判定为是多余节点，则删除。</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上是diff算法在vue中的应用，整个过程是先进行了：<br>1.旧开始 《-》新开始<br>2.旧结束 《-》 新结束<br>3.旧开始 《-》 新结束<br>4.旧结束 《-》 新开始<br>这四个方案的比较。如果这四种都不符合，那就再以旧节点为key进行map映射查找是否有新节点相同的节点，如果有，则把新节点放到旧开始节点前边，如果没有找到，则新建节点。<br>在整个比较过程中，<b>新旧节点顺序始终是不变的，操作的是真实DOM。</b><br>这里推荐一篇文章，非常的通俗易懂–&gt;<a href="https://www.infoq.cn/article/uDLCPKH4iQb0cR5wGY7f" target="_blank" rel="noopener">链接</a></p>
<blockquote>
<p>computed原码分析</p>
</blockquote>
<ul>
<li>原理分析<br>初始化computed属性是在initState中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initState (vm) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (opts.computed) &#123; initComputed(vm, opts.computed); &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>判断如果有computed属性，就执行initComputed初始化computed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function initComputed (vm, computed) &#123;</span><br><span class="line">    //  创建一个空对象，用来保存watchers对象,  在之后获取computed中的key时，会执行getter，getter就会从vm._computedWatchers中找到对应的key的watcher实例</span><br><span class="line">    var watchers = vm._computedWatchers = Object.create(null);</span><br><span class="line">    // 判断是否是服务端渲染</span><br><span class="line">    var isSSR = isServerRendering();</span><br><span class="line"></span><br><span class="line">    //  业务代码中声明的computed中的key，对应的方法作为getter</span><br><span class="line">    for (var key in computed) &#123;</span><br><span class="line">      var userDef = computed[key];</span><br><span class="line">      var getter = typeof userDef === &apos;function&apos; ? userDef : userDef.get;</span><br><span class="line">      if (getter == null) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          (&quot;Getter is missing for computed property \&quot;&quot; + key + &quot;\&quot;.&quot;),</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!isSSR) &#123;</span><br><span class="line">        // 创建一个临时watcher实例</span><br><span class="line">        watchers[key] = new Watcher(</span><br><span class="line">          vm,</span><br><span class="line">          getter || noop,</span><br><span class="line">          noop,</span><br><span class="line">          computedWatcherOptions</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //    computed中的key与data,prop不能重复，主要是做判断，如果合法，那就执行defineComputed</span><br><span class="line">      if (!(key in vm)) &#123;</span><br><span class="line">        defineComputed(vm, key, userDef);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (key in vm.$data) &#123;</span><br><span class="line">          warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined in data.&quot;), vm);</span><br><span class="line">        &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123;</span><br><span class="line">          warn((&quot;The computed property \&quot;&quot; + key + &quot;\&quot; is already defined as a prop.&quot;), vm);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来就是执行defineComputed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function defineComputed (</span><br><span class="line">    target,</span><br><span class="line">    key,</span><br><span class="line">    userDef</span><br><span class="line">  ) &#123;</span><br><span class="line">    var shouldCache = !isServerRendering();</span><br><span class="line">    if (typeof userDef === &apos;function&apos;) &#123;</span><br><span class="line">    //  使用Object.defineProperty定义computed中的key,getter就是createComputedGetter(key)</span><br><span class="line">      sharedPropertyDefinition.get = shouldCache</span><br><span class="line">        ? createComputedGetter(key)</span><br><span class="line">        : createGetterInvoker(userDef);</span><br><span class="line">      sharedPropertyDefinition.set = noop;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      sharedPropertyDefinition.get = userDef.get</span><br><span class="line">        ? shouldCache &amp;&amp; userDef.cache !== false</span><br><span class="line">          ? createComputedGetter(key)</span><br><span class="line">          : createGetterInvoker(userDef.get)</span><br><span class="line">        : noop;</span><br><span class="line">      sharedPropertyDefinition.set = userDef.set || noop;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">      sharedPropertyDefinition.set = function () &#123;</span><br><span class="line">        warn(</span><br><span class="line">          (&quot;Computed property \&quot;&quot; + key + &quot;\&quot; was assigned to but it has no setter.&quot;),</span><br><span class="line">          this</span><br><span class="line">        );</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Object.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到该方法是使用Object.defineProperty定义computed中的key,getter就是createComputedGetter(key)，看看他是怎么定义的getter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createComputedGetter (key) &#123;</span><br><span class="line">    return function computedGetter () &#123;</span><br><span class="line">      var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key];</span><br><span class="line">      if (watcher) &#123;</span><br><span class="line">        if (watcher.dirty) &#123;</span><br><span class="line">          watcher.evaluate();</span><br><span class="line">        &#125;</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">          watcher.depend();</span><br><span class="line">        &#125;</span><br><span class="line">        return watcher.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>getter的定义是从vm._computedWatchers中找到computed的key的watcher实例，创建watcher实例时，dirty是默认为true。第一次获取key，dirty是为true的话，就通过watcher.evaluate去计算key的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.evaluate = function evaluate () &#123;</span><br><span class="line">   this.value = this.get();</span><br><span class="line">   this.dirty = false;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们看到就是执行我们自定义的computed的key的方法，得到值赋值给了watcher实例，进行缓存，之后将dirty变为false,这样再次获取computed的key，就直接取值，避免再次计算。<br>那么再看get()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = function get () &#123;</span><br><span class="line">   //  将watcher实例赋值给了Dep.target，这里准备做依赖收集了</span><br><span class="line">   pushTarget(this);</span><br><span class="line">   var value;</span><br><span class="line">   var vm = this.vm;</span><br><span class="line">   try &#123;</span><br><span class="line">   //  这里就会去执行我们自定的computed的key的方法，如果方法中用到了data中的响应式属性，就会触发该属性的getter</span><br><span class="line">     value = this.getter.call(vm, vm);</span><br><span class="line">   &#125; catch (e) &#123;</span><br><span class="line">     if (this.user) &#123;</span><br><span class="line">       handleError(e, vm, (&quot;getter for watcher \&quot;&quot; + (this.expression) + &quot;\&quot;&quot;));</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       throw e</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">     // dependencies for deep watching</span><br><span class="line">     if (this.deep) &#123;</span><br><span class="line">       traverse(value);</span><br><span class="line">     &#125;</span><br><span class="line">     popTarget();</span><br><span class="line">     this.cleanupDeps();</span><br><span class="line">   &#125;</span><br><span class="line">   return value</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们看到去执行我们自定的computed的key的方法，如果方法中用到了data中的响应式属性，就会触发data的属性的getter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">get: function reactiveGetter () &#123;</span><br><span class="line">    var value = getter ? getter.call(obj) : val;</span><br><span class="line">    //  此时的Dep.target就是computed的key的watcher实例，就会进行依赖收集</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      if (childOb) &#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">        if (Array.isArray(value)) &#123;</span><br><span class="line">          dependArray(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>这样一来，当computed的key所依赖的data的key发生变化时，就会触发data的key的dep.notify()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dep.prototype.notify = function notify () &#123;</span><br><span class="line">  // stabilize the subscriber list first</span><br><span class="line">  var subs = this.subs.slice();</span><br><span class="line">  if (!config.async) &#123;</span><br><span class="line">    // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line">    // we need to sort them now to make sure they fire in correct</span><br><span class="line">    // order</span><br><span class="line">    subs.sort(function (a, b) &#123; return a.id - b.id; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  for (var i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是在update()中，并不会立即重新计算computed的key的值，而是把它的dirty变为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   */</span><br><span class="line">  Watcher.prototype.update = function update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true;</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是因为，当data的属性发生变化，就会重新渲染视图，触发_render重新渲染，而视图上依赖了computed的key,就会去获取这个key,触发key的getter,在getter中就会由于dirty为true，而再次evaluate()。<br>这便是整个computed的处理过程。</p>
<blockquote>
<p>watch源码分析</p>
</blockquote>
<ul>
<li>原理分析<br>初始化watch的入口是在initState中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function initState (vm) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">      initWatch(vm, opts.watch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看一下initWatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function initWatch (vm, watch) &#123;</span><br><span class="line">    for (var key in watch) &#123;</span><br><span class="line">      var handler = watch[key];</span><br><span class="line">      if (Array.isArray(handler)) &#123;</span><br><span class="line">        for (var i = 0; i &lt; handler.length; i++) &#123;</span><br><span class="line">          createWatcher(vm, key, handler[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        createWatcher(vm, key, handler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据观察的key的操作是否是数组还是单个函数，进行createWatcher操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createWatcher (</span><br><span class="line">    vm,</span><br><span class="line">    expOrFn,</span><br><span class="line">    handler,</span><br><span class="line">    options</span><br><span class="line">  ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //  这里的传参就是观察的key,自定义观察的key的函数</span><br><span class="line">    return vm.$watch(expOrFn, handler, options)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>返回的vm.$watch就是要去创建一个watcher实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = function (</span><br><span class="line">      expOrFn,</span><br><span class="line">      cb,</span><br><span class="line">      options</span><br><span class="line">    ) &#123;</span><br><span class="line">      ...</span><br><span class="line">      var watcher = new Watcher(vm, expOrFn, cb, options);</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Watcher = function Watcher (</span><br><span class="line">    vm,</span><br><span class="line">    expOrFn,</span><br><span class="line">    cb,</span><br><span class="line">    options,</span><br><span class="line">    isRenderWatcher</span><br><span class="line">  ) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // parse expression for getter</span><br><span class="line">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class="line">      this.getter = expOrFn;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn);</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter = noop;</span><br><span class="line">        warn(</span><br><span class="line">          &quot;Failed watching path: \&quot;&quot; + expOrFn + &quot;\&quot; &quot; +</span><br><span class="line">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class="line">          &apos;For full control, use a function instead.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get();</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在这里会去通过执行this.get()去获取watcher实例的value，这便是准备开始收集依赖了，和computed类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = function get () &#123;</span><br><span class="line">    //这里会把Dep.target设为watcher实例</span><br><span class="line">    pushTarget(this);</span><br><span class="line">    var value;</span><br><span class="line">    var vm = this.vm;</span><br><span class="line">    try &#123;</span><br><span class="line">        //然后会去执行观察的data的key的getter</span><br><span class="line">      value = this.getter.call(vm, vm);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, (&quot;getter for watcher \&quot;&quot; + (this.expression) + &quot;\&quot;&quot;));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      // dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value);</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget();</span><br><span class="line">      this.cleanupDeps();</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们只需要关心先把全局的Dep.target设为watcher实例，然后就去执行Object.defineProperty的getter,在getter中会判断如果有Dep.target,就会进行依赖收集.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">      get: function reactiveGetter () &#123;</span><br><span class="line">        var value = getter ? getter.call(obj) : val;</span><br><span class="line">        //  此时的target是上面提到的创建的watcher实例</span><br><span class="line">        if (Dep.target) &#123;</span><br><span class="line">            //进行依赖收集</span><br><span class="line">          dep.depend();</span><br><span class="line">          if (childOb) &#123;</span><br><span class="line">            childOb.dep.depend();</span><br><span class="line">            if (Array.isArray(value)) &#123;</span><br><span class="line">              dependArray(value);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return value</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样watch的key就完成了依赖的收集，当data的响应式属性变化时，就会dep.notify()通知subs中的watcher实例进行更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = function update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true;</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>更新并不是立即更新，而是通过queueWatcher放到队列中，再通过nextTick执行。<br>以上，便是watch的源码分析。</p>
<blockquote>
<p>vue-router源码分析</p>
</blockquote>
<ul>
<li><p>介绍<br>vue-router是官方的前端路由库，作为一个单页应用，路由功能可以使单页应用看起来更像个多页应用，可以更好地控制页面跳转。Vue提供的路由方式有<code>hash</code>,<code>history</code>,<code>abstract</code>。本文以v2.8为准来介绍。</p>
</li>
<li><p>原理分析<br>Vue引入插件是通过<code>Vue.use(plugin)</code>,<code>use</code>源码是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function initUse (Vue: GlobalAPI) &#123;</span><br><span class="line">  Vue.use = function (plugin: Function | Object) &#123;</span><br><span class="line">    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))</span><br><span class="line">    if (installedPlugins.indexOf(plugin) &gt; -1) &#123;</span><br><span class="line">      return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // additional parameters</span><br><span class="line">    const args = toArray(arguments, 1)</span><br><span class="line">    args.unshift(this)</span><br><span class="line">    if (typeof plugin.install === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; else if (typeof plugin === &apos;function&apos;) &#123;</span><br><span class="line">      plugin.apply(null, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主要是判断避免重复引入插件。初始化插件是把插件的<code>install</code>或插件导出的定义在此上下文中执行。</p>
<p><code>install</code>的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export function install (Vue) &#123;</span><br><span class="line">  if (install.installed &amp;&amp; _Vue === Vue) return</span><br><span class="line">  install.installed = true</span><br><span class="line"></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  const isDef = v =&gt; v !== undefined</span><br><span class="line"></span><br><span class="line">  const registerInstance = (vm, callVal) =&gt; &#123;</span><br><span class="line">    let i = vm.$options._parentVnode</span><br><span class="line">    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot = this</span><br><span class="line">        this._router = this.$options.router</span><br><span class="line">        this._router.init(this)</span><br><span class="line">        Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(this, this)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Vue.prototype, &apos;$router&apos;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Vue.prototype, &apos;$route&apos;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(&apos;router-view&apos;, View)</span><br><span class="line">  Vue.component(&apos;router-link&apos;, Link)</span><br><span class="line"></span><br><span class="line">  const strats = Vue.config.optionMergeStrategies</span><br><span class="line">  // use the same hook merging strategy for route hooks</span><br><span class="line">  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法使每个组件混入<code>beforeCreate</code>和<code>destroyed</code>方法,并响应式声明<code>_route</code>属性，定义<code>router-view</code>,<code>router-link</code>组件，并定义组件生命周期钩子。</p>
<p><code>install</code>是定义在<code>VueRouter</code>上的一个方法，回看<code>VueRouter</code>类是怎么声明的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">this.matcher = createMatcher(options.routes || [], this)</span><br><span class="line">//默认是hash模式，如果浏览器不支持history,就选择hash模式</span><br><span class="line">let mode = options.mode || &apos;hash&apos;</span><br><span class="line">this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false</span><br><span class="line">if (this.fallback) &#123;</span><br><span class="line">  mode = &apos;hash&apos;</span><br><span class="line">&#125;</span><br><span class="line">//如果不是在浏览器，就选择abstract模式</span><br><span class="line">if (!inBrowser) &#123;</span><br><span class="line">  mode = &apos;abstract&apos;</span><br><span class="line">&#125;</span><br><span class="line">this.mode = mode</span><br><span class="line"></span><br><span class="line">switch (mode) &#123;</span><br><span class="line">  case &apos;history&apos;:</span><br><span class="line">    this.history = new HTML5History(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  case &apos;hash&apos;:</span><br><span class="line">    this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">    break</span><br><span class="line">  case &apos;abstract&apos;:</span><br><span class="line">    this.history = new AbstractHistory(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  default:</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>通过<code>createMatcher</code>生成路由映射信息，然后对路由模式优雅降级,然后根据模式，选择具体的路由实体类。</p>
<p>router跳转是通过push方法，那么来看看push是怎么定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const &#123; current: fromRoute &#125; = this</span><br><span class="line">    //先执行transitionTo,并传了个回调成功函数</span><br><span class="line">    this.transitionTo(location, route =&gt; &#123;</span><br><span class="line">      pushState(cleanPath(this.base + route.fullPath))</span><br><span class="line">      handleScroll(this.router, route, fromRoute, false)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;, onAbort)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const route = this.router.match(location, this.current)</span><br><span class="line">    //先确认是否跳转</span><br><span class="line">    this.confirmTransition(route, () =&gt; &#123;</span><br><span class="line">      this.updateRoute(route)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      this.ensureURL()</span><br><span class="line"></span><br><span class="line">      // fire ready cbs once</span><br><span class="line">      if (!this.ready) &#123;</span><br><span class="line">        this.ready = true</span><br><span class="line">        this.readyCbs.forEach(cb =&gt; &#123; cb(route) &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, err =&gt; &#123;</span><br><span class="line">      if (onAbort) &#123;</span><br><span class="line">        onAbort(err)</span><br><span class="line">      &#125;</span><br><span class="line">      if (err &amp;&amp; !this.ready) &#123;</span><br><span class="line">        this.ready = true</span><br><span class="line">        this.readyErrorCbs.forEach(cb =&gt; &#123; cb(err) &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>confirmTransition</code>主要是判断是否是同一路由之间的跳转，如果不是的话，就把跳转之后需要调的任务放到任务队列中，这些任务主要是些生命周期钩子。<br>确认跳转之后就通过<code>updateRoute</code>更新路由，然后再执行push中的回调<code>pushState</code>，<br>具体看下updateRoute:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateRoute (route: Route) &#123;</span><br><span class="line">    const prev = this.current</span><br><span class="line">    this.current = route</span><br><span class="line">    this.cb &amp;&amp; this.cb(route)</span><br><span class="line">    this.router.afterHooks.forEach(hook =&gt; &#123;</span><br><span class="line">      hook &amp;&amp; hook(route, prev)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里执行cb,那么cb是在哪定义的呢？其实是在init中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.listen(route =&gt; &#123;</span><br><span class="line">    this.apps.forEach((app) =&gt; &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>又因为在前面定义了响应式属性<code>_route</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current),</span><br></pre></td></tr></table></figure></p>
<p>所以就会触发组件的setter, setter中调用dep中收集的依赖，触发render,再通过nextTick重新渲染。<br>router-view中组件定义了render方法，在该方法中其实是执行$createElement去渲染组件</p>
<blockquote>
<p>Vuex原理分析</p>
</blockquote>
<ul>
<li><p>介绍<br>Vuex是一个可以全局组件共享数据的插件，通过actions -&gt; mutations -&gt; state的流程，可以更加规范化数据操作。</p>
</li>
<li><p>原理分析<br>Vue通过<code>install</code>方法加载Vuex实例，主要是通过<code>mixin</code>在<code>beforeCreate</code>时来给Vue扩展方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function vuexInit () &#123;</span><br><span class="line">   const options = this.$options</span><br><span class="line">   // store injection</span><br><span class="line">   if (options.store) &#123;</span><br><span class="line">     this.$store = typeof options.store === &apos;function&apos;</span><br><span class="line">       ? options.store()</span><br><span class="line">       : options.store</span><br><span class="line">   &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">     this.$store = options.parent.$store</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>vuexInit</code>主要是把store实例挂载到this.$store上，子组件从其父组件引用$store属性，层层嵌套进行设置,以此来达到给全局组件注入store的目的。<br>那么再来看Store是怎么定义的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">export class Store &#123;</span><br><span class="line">    constructor (options = &#123;&#125;) &#123;</span><br><span class="line">        //省略部分代码</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        //当正在执行mutations时，就改变_committing状态，改变结束，再更改回来，用于区分是否是通过mutations来改变state,而不是直接修改state</span><br><span class="line">        this._committing = false</span><br><span class="line">        </span><br><span class="line">        //把定义的action方法放进对象做一个映射集</span><br><span class="line">        this._actions = Object.create(null)</span><br><span class="line">        </span><br><span class="line">        //把定义的mutation方法放进对象做一个映射集</span><br><span class="line">        this._mutations = Object.create(null)</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">        // 定义dispatch和commit</span><br><span class="line">        const store = this</span><br><span class="line">        const &#123; dispatch, commit &#125; = this</span><br><span class="line">        this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class="line">          return dispatch.call(store, type, payload)</span><br><span class="line">        &#125;</span><br><span class="line">        this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class="line">          return commit.call(store, type, payload, options)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //初始化data getters</span><br><span class="line">        resetStoreVM(this, state)</span><br><span class="line">        </span><br><span class="line">        // 安装插件</span><br><span class="line">        plugins.forEach(plugin =&gt; plugin(this))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例化Store中，把定义的mutation和action都各自放进了一个映射集合，然后在执行时，通过方法名称去执行对应方法，然后再看是如何定义了dispatch和commit的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dispatch (_type, _payload) &#123;</span><br><span class="line">    // check object-style dispatch</span><br><span class="line">    const &#123;</span><br><span class="line">      type,</span><br><span class="line">      payload</span><br><span class="line">    &#125; = unifyObjectStyle(_type, _payload)</span><br><span class="line"></span><br><span class="line">    const action = &#123; type, payload &#125;</span><br><span class="line">    </span><br><span class="line">    //通过type找到需要执行的方法</span><br><span class="line">    const entry = this._actions[type]</span><br><span class="line">    if (!entry) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        console.error(`[vuex] unknown action type: $&#123;type&#125;`)</span><br><span class="line">      &#125;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._actionSubscribers.forEach(sub =&gt; sub(action, this.state))</span><br><span class="line">    </span><br><span class="line">    return entry.length &gt; 1</span><br><span class="line">      ? Promise.all(entry.map(handler =&gt; handler(payload)))</span><br><span class="line">      : entry[0](payload)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>commit</code>和<code>dispatch</code>类似，只不过多了一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> this._withCommit(() =&gt; &#123;</span><br><span class="line">  entry.forEach(function commitIterator (handler) &#123;</span><br><span class="line">    handler(payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这个_withCommit就是用来在mutation改变state时，改变一下状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_withCommit (fn) &#123;</span><br><span class="line">    const committing = this._committing</span><br><span class="line">    this._committing = true</span><br><span class="line">    fn()</span><br><span class="line">    this._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看state和getter是怎么定义的,这两个的定义是在初始化Store时，有个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">    //省略部分代码</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    const computed = &#123;&#125;</span><br><span class="line">      forEachValue(wrappedGetters, (fn, key) =&gt; &#123;</span><br><span class="line">        // use computed to leverage its lazy-caching mechanism</span><br><span class="line">        computed[key] = () =&gt; fn(store)</span><br><span class="line">        Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">          get: () =&gt; store._vm[key],</span><br><span class="line">          enumerable: true // for local getters</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    store._vm = new Vue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">          $$state: state</span><br><span class="line">        &#125;,</span><br><span class="line">        computed</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过创建一个响应式的data和computed来实现state和getters。<br>我们在在组件中使用Vuex时，经常会通过<code>import { mapGetters, mapActions } from &#39;vuex&#39;</code>来直接使用action或mutation的方法，那么他们是怎么实现的呢：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123;</span><br><span class="line">  const res = &#123;&#125;</span><br><span class="line">  normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123;</span><br><span class="line">    res[key] = function mappedAction (...args) &#123;</span><br><span class="line">      let dispatch = this.$store.dispatch</span><br><span class="line">      //如果有命名空间</span><br><span class="line">      if (namespace) &#123;</span><br><span class="line">        const module = getModuleByNamespace(this.$store, &apos;mapActions&apos;, namespace)</span><br><span class="line">        if (!module) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch = module.context.dispatch</span><br><span class="line">      &#125;</span><br><span class="line">      return typeof val === &apos;function&apos;</span><br><span class="line">        ? val.apply(this, [dispatch].concat(args))</span><br><span class="line">        : dispatch.apply(this.$store, [val].concat(args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其实就是从_actions方法集合中,找到该方法，dispatch绑定$store上下文，并返回新的方法集合。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/blog/tags/Vue/" rel="tag"># Vue</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2020/03/06/docker+node记录/" rel="next" title="docker+node记录">
                <i class="fa fa-chevron-left"></i> docker+node记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2021/06/16/Web安全头/" rel="prev" title="Web安全头">
                Web安全头 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">三木</p>
              <p class="site-description motion-element" itemprop="description">前端开发,web,javascript,技术博客,程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三木</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4<span class="post-meta-divider">|</span> <a href="http://www.beian.miit.gov.cn/" target="_blank">冀ICP备16017076号</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/blog/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/blog/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '4LkpBNg9FTbpqeub70uBoQdg-gzGzoHsz',
        appKey: 'Ct2vI8ajVHfosTqP9hIFpNCs',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
